### 总结几种 socket 粘包的解包方式：fix length/delimiter based/length field based frame decoder。尝试举例其应用。
### 什么是粘包和半包？
粘包问题是指当发送两条消息时，比如发送了 ABC 和 DEF，但另一端接收到的却是 ABCD，像这种一次性读取了两条数据的情况就叫做粘包（正常情况应该是一条一条读取的）。

代码示例："geekbang_study/homework/network/tcp/client.go"，循环多次发送消息时会出现。

半包问题是指，当发送的消息是 ABC 时，另一端却接收到的是 AB 和 C 两条信息，像这种情况就叫做半包。

### 为什么会出现粘包和半包？
主要原因TCP是面向连接的传输协议，TCP数据传递模式是流模式，而流数据是没有明确的开始结尾边界，所以 TCP 也没办法判断哪一段流属于一个消息，进而在保持长连接的时候可以进行多次的收和发。

### 粘包的主要原因：

发送方每次写入数据 < 套接字（Socket）缓冲区大小；

接收方读取套接字（Socket）缓冲区数据不够及时。

### 半包的主要原因：

发送方每次写入数据 > 套接字（Socket）缓冲区大小；

发送的数据大于协议的 MTU (Maximum Transmission Unit，最大传输单元)，因此必须拆包。

### 什么是缓冲区？

缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。

缓冲区的优势以文件流的写入为例，如果我们不使用缓冲区，那么每次写操作 CPU 都会和低速存储设备也就是磁盘进行交互，那么整个写入文件的速度就会受制于低速的存储设备（磁盘）。但如果使用缓冲区的话，每次写操作会先将数据保存在高速缓冲区内存上，当缓冲区的数据到达某个阈值之后，再将文件一次性写入到磁盘上。因为内存的写入速度远远大于磁盘的写入速度，所以当有了缓冲区之后，文件的写入速度就被大大提升了。

### 粘包和半包的几种解决办法：
出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。

**1、fix length**

发送方和接收方规定固定大小的缓冲区，也就是发送和接收都使用固定大小的 []byte 数组长度，当字符长度不够时使用空字符弥补。

**2、delimiter based**

以特殊的字符结尾，比如以“\n”结尾，这样我们就知道结束字符，从而避免了半包和粘包问题。

**3、length field based frame decoder**

封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确拆分出一个完整的数据包。

在 TCP 协议的基础上封装一层数据请求协议，即将数据包封装成数据头（存储数据正文大小）+ 数据正文的形式，这样在服务端就可以知道每个数据包的具体长度了，知道了发送数据的具体边界之后，就可以解决半包和粘包的问题了。

### 实现一个从 socket connection 中解码出 goim 协议的解码器。

见代码："geekbang_study/homework/network/proto/goim.go"